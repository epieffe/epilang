use crate::compiler::ast::AST;
use crate::intermediate::opcode::{BinaryOpcode, UnaryOpcode};
use crate::intermediate::constant::Constant;

use std::str::FromStr;

grammar;

pub AST: Box<AST> = {
    <left:AST> ";" <right:Assignment> => Box::new(AST::Concatenation{ left: left, right: right }),
    Assignment,
}

Term: Box<AST> = {
    "let" <Identifier> => Box::new(AST::Definition(<>)),
    "if" <exp:AST> "{" <thn:AST> "}" => Box::new(AST::Condition{ exp: exp, then_block: thn, else_block: Box::new(AST::Constant(Constant::Int(0))) }),
    "if" <exp:AST> "{" <thn:AST> "}" "else" "{" <els:AST> "}" => Box::new(AST::Condition{ exp: exp, then_block: thn, else_block: els }),
    "{" <AST> "}" => Box::new(AST::Block(<>)),
    "(" <AST> ")" => Box::new(AST::Block(<>)),
    IntNum => Box::new(AST::Constant(Constant::Int(<>))),
    FloatNum => Box::new(AST::Constant(Constant::Float(<>))),
    StringLiteral => Box::new(AST::Constant(Constant::String(<>))),
    BoolLiteral => Box::new(AST::Constant(Constant::Bool(<>))),
    Identifier => Box::new(AST::Identifier(<>)),
}

Assignment: Box<AST> = {
    <Assignment> "=" <Disjunction> => Box::new(AST::Assignment(<>)),
    Disjunction
}

Disjunction: Box<AST> = {
    Disjunction DisjOp Conjunction => Box::new(AST::BinaryOp(<>)),
    Conjunction,
}

DisjOp: BinaryOpcode = {
    "||" => BinaryOpcode::Disj,
}

Conjunction: Box<AST> = {
    Conjunction ConjOp Comparison => Box::new(AST::BinaryOp(<>)),
    Comparison,
}

ConjOp: BinaryOpcode = {
    "&&" => BinaryOpcode::Conj,
}

Comparison: Box<AST> = {
    Comparison CompareOp Summ => Box::new(AST::BinaryOp(<>)),
    Summ,
}

CompareOp: BinaryOpcode = {
    "==" => BinaryOpcode::Equals,
    "!=" => BinaryOpcode::NotEquals,
    "<" => BinaryOpcode::Lower,
    ">" => BinaryOpcode::Greater,
    "<=" => BinaryOpcode::LowerEquals,
    ">=" => BinaryOpcode::GreaterEquals,
}

Summ: Box<AST> = {
    Summ SummOp Factor => Box::new(AST::BinaryOp(<>)),
    Factor,
}

SummOp: BinaryOpcode = {
    "+" => BinaryOpcode::Add,
    "-" => BinaryOpcode::Sub,
}

Factor: Box<AST> = {
    Factor FactorOp UnaryResult => Box::new(AST::BinaryOp(<>)),
    UnaryResult,
}

FactorOp: BinaryOpcode = {
    "*" => BinaryOpcode::Mul,
    "/" => BinaryOpcode::Div,
}

UnaryResult: Box<AST> = {
    UnaryOp Term => Box::new(AST::UnaryOp(<>)),
    Term,
}

UnaryOp: UnaryOpcode = {
    "!" => UnaryOpcode::Not,
}

Identifier: String = {
    r"[a-zA-Z][a-zA-z_0-9]*" => <>.to_owned()
}

IntNum: i32 = {
    r"-?[0-9]+" => i32::from_str(<>).unwrap()
}

FloatNum: f32 = {
    r"-?[0-9]+\.[0-9]+" => f32::from_str(<>).unwrap()
}

StringLiteral: String = {
    r#""[^"]*""# => <>[1..<>.len() - 1].to_owned()
}

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
}
